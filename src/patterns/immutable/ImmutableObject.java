package patterns.immutable;

public class ImmutableObject {

    /**
     *
     * Супер-надежная концепция потокобезопасности - объект, внутреннее состояние которого нельзя
     * изменить, потому что:
     *
     * 1. Все его поля находятся в финальном классе.
     * 2. Все его поля сделаны приватными и финальными.
     * 3. Отсутствуют сеттеры.
     *
     * Таким образом любой поток, требующий создания такого класса, всегда получает
     * НОВЫЙ объект, не застрагивая, таким образом, изменения, возможно, внесенные другими
     * потоками.
     *
     * Для изменения внутреннего состояния такого объекта применяется специальный приём -
     * вызов фабрики объекта, ссылка на который предоставляется не конструктором, а полем с квалификатором
     * volatile.
     *
     * Смысл его наличия здесь и функциональность заключается в следующем.
     *
     * В многопоточной среде согласно существующей модели памяти JVM используется две методологии управления
     * кодом. Если на выполнение созданным потоком попадает некий объект, то последовательность выполнения
     * его инструкций может быть переупорядочена, если это возможно, с целью сделать возможным параллельное выполнение.
     * Эту методологию называют reordering.
     *
     * Вторая методология относится к эффекту, связанному с тем, что созданные потоки, запущенные, возможно,
     * на физически разных ядрах процессора, имеют несколько дополнительных уровней кеша процессора и инструкции,
     * выполняемые в главном потоке программы, могут быть не видны в контексте потока, который создан и выполняется
     * отдельно. Это явление называется memory visibility.
     *
     * Таким образом, если некий метод обозначен инструкцией synchronized, от он, как мы знаем, получает
     * лок и мы точно знаем, что никакой другой поток никогда не получит управления над этим же самым методом любого
     * другого потока до тех пор, пока лок не будет снят. Фактически это означает, что управление кодом отдается
     * потоку таким образом, что он может быть запланирован на выполнение на другом физическом процессоре ядра, от которого
     * его отделяет дополнительный слой кешей. Таким образом, здесь мог бы наступить эффект memory visibility. Другими словами,
     * если бы виртуальная машина не предпринимала дополнительных усилий, могло случиться так, что результаты работы потока
     * могут быть не видны другим потокам и, таким образом, согласованное состояние может быть нарушено. Для того, чтобы этого
     * избежать, как мы знаем, используется механизм happens-before, гарантирующий сброс памяти конкретного потока в основную память
     * с тем, чтобы поток, который планирует начать свою работу, смог бы прочитать его и начать свою обработку с учётом
     * результатов, организованных предыдущим потоком.
     *
     * Механизм  volatile  ведет себя по-другому. Если объект, обладающий таким полем, попадает в контекст выполнения
     * другого потока, но значение волатильного поля всегда находится в памяти главного потока программы, гарантируя тем самым,
     * что значение, находящееся в таком поле, всегда будет видимо для любых потоков без применения happens-before, как это было
     * верно для синхронизированных методов.
     *
     * Таким образом, наш иммьютабельный объект может быть сравнительно быстро (за счет наличия этого поля в главной памяти)
     * использован в многопоточной среде. При этом, поскольку мы организовали логику особенным образом, что фабрика класса всегда
     * отдаёт НОВЫЙ объект, его использование является потокобезопасным.
     *
     */

    private volatile MyImmutableObject safeReference = new MyImmutableObject(0, "", false);

    public void updateField(int id, String newValue, boolean newAnotherValue) {
        this.safeReference = new MyImmutableObject(id, newValue, newAnotherValue);
    }

    public void printMyImmutableObject() {
        System.out.println(safeReference);
    }

    public final static class MyImmutableObject {
        private final int id;
        private final String aValue;
        private final boolean anotherValue;

        public MyImmutableObject(int id, String aValue, boolean anotherValue) {
            super();
            this.id = id;
            this.aValue = aValue;
            this.anotherValue = anotherValue;
        }

        public int getId() {
            return id;
        }

        public String getaValue() {
            return aValue;
        }

        public boolean getAnotherValue() {
            return anotherValue;
        }

        @Override
        public String toString() {
            return "MyImmutableObject [id=" + id + ", aValue=" + aValue + ", anotherValue=" + anotherValue + "]";
        }

    }
}
